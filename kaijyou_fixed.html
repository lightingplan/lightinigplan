<!DOCTYPE html>
<html lang="ja">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/exceljs/dist/exceljs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>


<head>
  <meta charset="UTF-8" />
  <title>ä¼šå ´é¸æŠï¼†è¡¨ç¤ºï¼‹ç¯ä½“ç¨®é¡é¸æŠï¼‹ä¿¡å·ç·š</title>
  <style>
    body { font-family: sans-serif; }
    #venueSelector {
      text-align: center;
      margin: 30px auto;
    }
    #venueList button {
      display: block;
      width: 300px;
      margin: 10px auto;
      padding: 10px;
      font-size: 16px;
      cursor: pointer;
    }
    #stage {
      width: 800px;
      height: 600px;
      margin: 0 auto;
      position: relative;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      border: 2px solid #ccc;
      display: none;
      user-select: none;
      overflow: auto;
    }
    #toggleEditBtn, #addLightBtn, #backBtn, #addother, #addstand, #addcontroller{
      display: inline-block;
      margin: 10px;
      padding: 6px 12px;
      font-size: 14px;
      cursor: pointer;
    }
    #fixtureSelector {
      font-size: 14px;
      margin-left: 10px;
    }
    .light {
      width: 60px;
      height: 30px;
      background-color: gray;
      color: white;
      font-size: 12px;
      text-align: center;
      line-height: 30px;
      position: absolute;
      border: 2px solid #555;
      cursor: move;
      user-select: none;
      box-sizing: border-box;
      transition: box-shadow 0.3s;
      overflow: visible; 
      resize: none;
      z-index: 3; /* èƒŒæ™¯ */
    }

    .resize-handle {
      width: 10px;
      height: 10px;
      background-color: black;
      position: absolute;
      right: 0;
      bottom: 0;
      cursor: nwse-resize;
    }
    
    .light.stinger { 
      width: 100%;
      max-width: 100px;
      height: auto;
      aspect-ratio: 1 / 1;             /* æ­£æ–¹å½¢ã«ã—ãŸã„å ´åˆ */
      object-fit: cover;
      background: url("images/STINGER.png") no-repeat center center;
      background-size: contain; 
                  }
    .light.sweeper {
      width: 28%;
      max-width: 150px; /* stingerã¨åŒã˜å¹…åˆ¶é™ */
      aspect-ratio: 2 / 1; /* æ¨ªé•·ï¼ˆä¾‹ï¼š100px Ã— 50pxï¼‰ */
      background: url("images/sweepar.png") no-repeat center center;
      background-size: contain;
    }
    .light.sunray { 
      width: 28%;
      max-width: 150px; /* â† stingerã‚„sweeperã¨æƒãˆã‚‹ */
      aspect-ratio: 1 / 1; /* æ¨ªé•·æ¯”ç‡ï¼ˆå¿…è¦ã«å¿œã˜ã¦1.5ã‚„2.5ãªã©ã«ï¼‰ */
      background: url("images/sunray.png") no-repeat center center;
      background-size: contain;
                  }
    .light.tiny { background-color: rgb(255, 255, 255); }
    .light.inno {
      width: 28%;
      max-width: 50px;
      aspect-ratio: 1 / 2; /* â† innoãŒæ­£æ–¹å½¢ãªã‚‰ã“ã‚Œã€æ¨ªé•·/ç¸¦é•·ãªã‚‰å¤‰ãˆã‚‹ */
      background: url("images/inno.png") no-repeat center center;
      background-size: contain;
    }

    .light.mk3 { 
      width: 28%;
      max-width: 50px;
      aspect-ratio: 1 / 2; 
      background: url("images/mk3.png") no-repeat center center; 
      background-size: contain;
                  }
    .light.dotz { 
      width: 28%;
      max-width: 50px;
      aspect-ratio: 1 / 2; 
      background: url("images/dots.png")no-repeat center center; 
      background-size: contain;; 
                  }
    .light.mk2 { 
      width: 28%;
      max-width: 50px;
      aspect-ratio: 1 / 2; 
      background: url("images/mk2.png")no-repeat center center; 
      background-size: contain;; 
                  }
    .light.ledpar { 
      width: 28%;
      max-width: 50px;
      aspect-ratio: 1 / 2; 
      background: url("images/par.png")no-repeat center center; 
      background-size: contain;; ; 
                  }
    .light.cspot { background-color: rgb(34, 139, 97); }
    .light.metubusi { 
      width: 28%;
      max-width: 100px;
      aspect-ratio: 1 / 1; 
      background: url("images/miniburu.png")no-repeat center center; 
      background-size: contain;; ; 
                  }
    .light.selected {
      border-color: #00f;
      box-shadow: 0 0 8px #00f;
    }
    .light .controls {
      position: absolute;
      top: -20px;
      right: -20px;
      display: flex;
      gap: 2px;
      visibility: hidden;
    }
    .light:hover .controls {
      visibility: visible;
    }
    .control-btn {
      width: 18px;
      height: 18px;
      font-size: 12px;
      line-height: 16px;
      text-align: center;
      background-color: #333;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }
    /* SVG ä¿¡å·ç·šç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
    #signalLines {
      position: absolute;
      top: 0; left: 0;
      pointer-events: none; /* åŸºæœ¬ã¯ç·šã¯ãƒ‰ãƒ©ãƒƒã‚°ç„¡åŠ¹ */
      width: 800px;
      height: 600px;
      z-index: 0; /* stageã‚ˆã‚Šå‰é¢ */
    }


    line.signal-line {
      stroke: orange;
      stroke-width: 3;
      cursor: pointer;
      pointer-events: all; /* ç·šã®ã‚¯ãƒªãƒƒã‚¯ã‚’æœ‰åŠ¹åŒ– */
      transition: stroke 0.3s;
    }
    line.signal-line.selected {
      stroke: deepskyblue;
      stroke-width: 5;
    }
    .handle-br {
      bottom: 0;
      right: 0;
    }

  .rotate-handle {
  width: 10px;
  height: 10px;
  background: red;
  border-radius: 50%;
  position: absolute;
  top: -20px;
  left: 50%;
  transform: translateX(-50%);
  cursor: grab;
}

.length-label {
  position: absolute;
  background: white;
  border: 1px solid black;
  padding: 2px 4px;
  border-radius: 4px;
  font-size: 12px;
  pointer-events: none;
  transform: translate(-50%, -50%);
  white-space: nowrap;
  z-index: 1000;
}

.other {
      width: 60px;
      height: 30px;
      background-color: gray;
      color: white;
      font-size: 12px;
      text-align: center;
      line-height: 30px;
      position: absolute;
      border: 2px solid #555;
      cursor: move;
      user-select: none;
      box-sizing: border-box;
      transition: box-shadow 0.3s;
      overflow: visible;
      resize: none;
      z-index: 1; /* èƒŒæ™¯ */
    }

    .other.woodbox {
      width: 60px;
      height: 60px;
      background-color: rgb(151, 86, 6);
    }

    .other.tutu {
      clip-path: polygon(50% 0, 100% 100%, 0 100%);
      height: calc(60px / 2 * tan(60deg));
      width: 60px;
      background-color: rgb(67, 141, 219);
    }


    .other.selected {
      border-color: #00f;
      box-shadow: 0 0 8px #00f;
    }

    .othercontrols {
      position: absolute;
      top: -20px;
      right: -20px;
      display: flex;
      gap: 2px;
      visibility: hidden;
    }

    .other:hover .othercontrols {
      visibility: visible;
    }

    #otherSelector {
      font-size: 14px;
      margin-left: 10px;
    }

    #venueList {
      text-align: center;
      margin-bottom: 20px;
    }

    .stand {
      width: 60px;
      height: 30px;
      background-color: gray;
      color: white;
      font-size: 12px;
      text-align: center;
      line-height: 30px;
      position: absolute;
      border: 2px solid #555;
      cursor: move;
      user-select: none;
      box-sizing: border-box;
      transition: box-shadow 0.3s;
      overflow: visible;
      resize: none;
    }

    .stand.blackstand {
      background-color: rgb(0, 0, 0);
    }

    .stand.silverstand {
      background-color: rgb(132, 132, 132);
    }

    .stand.selected {
      border-color: #00f;
      box-shadow: 0 0 8px #00f;
    }

    .standcontrols {
      position: absolute;
      top: -20px;
      right: -20px;
      display: flex;
      gap: 2px;
      visibility: hidden;
    }

    .stand:hover .stnadcontrols {
      visibility: visible;
    }

    #standSelector {
      font-size: 14px;
      margin-left: 10px;
    }         

    #controllerSelector {
      font-size: 14px;
      margin-left: 10px;
    }
    .controller {
      width: 60px;
      height: 30px;
      background-color: gray;
      color: white;
      font-size: 12px;
      text-align: center;
      line-height: 30px;
      position: absolute;
      border: 2px solid #555;
      cursor: move;
      user-select: none;
      box-sizing: border-box;
    }
    .controller.selected {
      border-color: #00f;
      box-shadow: 0 0 8px #00f;
    }

    .address-label {
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      background: yellow;
      color: black;
      font-size: 10px;
      padding: 2px 4px;
      border-radius: 4px;
      pointer-events: none;
    }

    .address-label {
      position: absolute;
      top: -14px;
      left: 50%;
      transform: translateX(-50%);
      background: yellow;
      color: black;
      font-size: 10px;
      padding: 2px 4px;
      border-radius: 4px;
      pointer-events: none;
      z-index: 10;
  }

    .bend-handle {
      pointer-events: auto;
    }

  /* ç·¨é›†ãƒ¢ãƒ¼ãƒ‰OFFã®ã¨ãã¯ãƒãƒ³ãƒ‰ãƒ«éè¡¨ç¤º */
.stage-non-edit .resize-handle,
.stage-non-edit .rotate-handle {
  display: none !important;
}
line.signal-line.selected,
polyline.selected {
  stroke: deepskyblue;
  stroke-width: 5;
}



  </style>
</head>
<body>

<div id="venueSelector">
  <h2>ä¼šå ´ã‚’é¸ã‚“ã§ãã ã•ã„</h2>
  <div id="venueList"></div>
</div>

<div id="stage">
  <button id="toggleEditBtn">ç·¨é›†ãƒ¢ãƒ¼ãƒ‰: ON</button>
  <select id="fixtureSelector">
    <option value="STINGERâ…¡">STINGERâ…¡</option>
    <option value="SWEEPER BEAM QUAD LED">SWEEPER BEAM QUAD LED</option>
    <option value="LIGHT BOX">LIGHT BOX</option>
    <option value="Sunray TRI LED">Sunray TRI LED</option>
    <option value="Tiny LED">Tiny LED</option>
    <option value="Inno Spot">Inno Spot</option>
    <option value="QUADRA Par120 mk-3">QUADRA Par120 mk-3</option>
    <option value="Dotz Par">Dotz Par</option>
    <option value="E-PAR56LED mk2">E-PAR56LED mk2</option>
    <option value="LED PAR64">LED PAR64</option>
    <option value="CSPOT26">CSPOT26</option>
  </select>

  <button id="addLightBtn">ç¯ä½“ã‚’è¿½åŠ </button>
  <button id="backBtn">æˆ»ã‚‹</button>
  <button id="connectModeBtn">æ¥ç¶šãƒ¢ãƒ¼ãƒ‰: OFF</button>

    <select id="otherSelector">
      <option value="woodbox">æœ¨ç®±</option>
      <option value="tutu">ç­’</option>
    </select>
    <button id="addother">ãã®ä»–è¿½åŠ </button>

    <select id="standSelector">
      <option value="blackstand">é»’ã‚¹ã‚¿</option>
      <option value="silverstand">éŠ€ã‚¹ã‚¿</option>
    </select>
    <button id="addstand">ã‚¹ã‚¿ãƒ³ãƒ‰è¿½åŠ </button>

  <select id="controllerSelector">
    <option value="phantom2048">phantom2048</option>
    <option value="SEANESETTER">SEANESETTER</option>
  </select>
  <button id="addcontroller">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼è¿½åŠ </button>

  
  <button id="downloadPdfBtn">PDFãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>


  <!-- ä¿®æ­£é–‹å§‹ï¼šä¿¡å·ç·šç®¡ç†å¼·åŒ– -->
<!-- ä¿¡å·ç·šç”¨SVG -->
  <svg id="signalLines" xmlns="http://www.w3.org/2000/svg"></svg>
</div>

<div id="equipmentList" style="position: fixed; right: 10px; bottom: 10px; background: white; padding: 10px; border: 1px solid #ccc; max-height: 200px; overflow-y: auto;">
  <h3>æ©Ÿæãƒªã‚¹ãƒˆ</h3>

    <ul id="fixtureList"></ul>
    <ul id="cableList"></ul>
    <ul id="otherList"></ul>
    <ul id="standList"></ul>
    <ul id="controllerList"></ul>
    <button id="downloadExcel">ç½«ç·šä»˜ãExcelã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
</div>

<div id="faderTable" style="position: fixed; left: 10px; bottom: 10px; background: white; padding: 10px; border: 1px solid #ccc; max-height: 300px; overflow-y: auto;">
  <h3>ãƒ•ã‚§ãƒ¼ãƒ€ãƒ¼è¡¨</h3>
  <table id="faderList" border="1" style="border-collapse: collapse;">
    <thead>
      <tr><th>åå‰</th><th>ç¨®é¡</th><th>ã‚¢ãƒ‰ãƒ¬ã‚¹</th></tr>
    </thead>
    <tbody></tbody>
  </table>
  <button id="downloadFaderCsvBtn">CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
  <button id="sortFaderBtn">ã‚¢ãƒ‰ãƒ¬ã‚¹é †ã«ä¸¦ã³æ›¿ãˆ</button>

  

</div>





<script>
const venues = [
  { id: "hallA", name: "ãƒ›ãƒ¼ãƒ«A", backgroundImage: "images/hallA.png" },
  { id: "hallB", name: "ãƒ›ãƒ¼ãƒ«B", backgroundImage: "images/hallB.png" },
  { id: "hallC", name: "ãƒ›ãƒ¼ãƒ«C", backgroundImage: "images/hallC.png" },
  { id: "hallD", name: "ãƒ›ãƒ¼ãƒ«D", backgroundImage: "images/hallD.png" }
];

const venueSelector = document.getElementById("venueSelector");
const venueListDiv = document.getElementById("venueList");
const stage = document.getElementById("stage");
const toggleEditBtn = document.getElementById("toggleEditBtn");
const addLightBtn = document.getElementById("addLightBtn");
const backBtn = document.getElementById("backBtn");
const fixtureSelector = document.getElementById("fixtureSelector");
const signalLinesSVG = document.getElementById("signalLines");
const connectModeBtn = document.getElementById("connectModeBtn");
const addOtherBtn = document.getElementById("addother");
const otherSelector = document.getElementById("otherSelector");
const addStandBtn = document.getElementById("addstand");
const standSelector = document.getElementById("standSelector");
const addControllerBtn = document.getElementById("addcontroller");
const standController = document.getElementById("controllerSelector");

const selectedOthers = new Set();
let lastSelectedOther = null;
const selectedStands = new Set();
let lastSelectedStand = null;
const selectedControllers = new Set();
let lastSelectedController = null;


let editMode = true;
let lightCount = 0;
let otherCount = 0;
let standCount = 0;
let controllerCount = 0;

venues.forEach(v => {
  const btn = document.createElement("button");
  btn.textContent = v.name;
  btn.onclick = () => {
    venueSelector.style.display = "none";
    stage.style.display = "block";
    stage.style.backgroundImage = `url(${v.backgroundImage})`;
    updateSvgSize();// SVGã‚µã‚¤ã‚ºæ›´æ–°
    addController();
    addLight();
   };
  venueSelector.appendChild(btn);
 });



function renderVenueList() {
  venueListDiv.innerHTML = "";
  venues.forEach(v => {
    const btn = document.createElement("button");
    btn.textContent = v.name;
    btn.onclick = () => loadVenue(v.id);
    venueListDiv.appendChild(btn);
  });
}

function loadVenue(id) {
  const venue = venues.find(v => v.id === id);
  if (!venue) return;

  venueSelector.style.display = "none";
  stage.style.display = "block";
  stage.style.backgroundImage = `url('${venue.backgroundImage}')`;

  // ç¯ä½“ãƒªã‚»ãƒƒãƒˆ
  stage.querySelectorAll(".light").forEach(el => el.remove());
  // ç·šãƒªã‚»ãƒƒãƒˆ
  clearAllSignalLines();
  // ãã®ä»–ãƒªã‚»ãƒƒãƒˆ
  stage.querySelectorAll(".other").forEach(el => el.remove());
  // ã‚¹ã‚¿ãƒ³ãƒ‰ãƒªã‚»ãƒƒãƒˆ
  stage.querySelectorAll(".stand").forEach(el => el.remove());
  // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãƒªã‚»ãƒƒãƒˆ
  stage.querySelectorAll(".controller").forEach(el => el.remove());

  lightCount = 0;
  selectedLights.clear();
  selectedLines.clear();
  selectedOthers.clear();
  selectedControllers.clear();
  lineConnectMode = false;
  connectingLights = [];
  connectingControllers = [];
  updateLineConnectModeUI();
}

// ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ã«ã™ã‚‹é–¢æ•°
function makeDraggable(el) {
  let offsetX = 0, offsetY = 0;

  el.onmousedown = (e) => {
    if (!editMode) return;
    // ä¿¡å·ç·šã®æ¥ç¶šãƒ¢ãƒ¼ãƒ‰ä¸­ã¯ãƒ‰ãƒ©ãƒƒã‚°ç¦æ­¢
    if(lineConnectMode) return;

    offsetX = e.offsetX;
    offsetY = e.offsetY;

    const onMouseMove = (e2) => {
      let newLeft = e2.pageX - stage.offsetLeft - offsetX;
      let newTop = e2.pageY - stage.offsetTop - offsetY;

      // ã‚¹ãƒ†ãƒ¼ã‚¸å†…ã«åã‚ã‚‹åˆ¶é™
      newLeft = Math.min(Math.max(0, newLeft), stage.clientWidth - el.offsetWidth);
      newTop = Math.min(Math.max(0, newTop), stage.clientHeight - el.offsetHeight);

      el.style.left = newLeft + "px";
      el.style.top = newTop + "px";

      updateLinesForLight(el);
      updateLinesForController(el);
    };

    const onMouseUp = () => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    };

    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  };
}

// ç·¨é›†ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
toggleEditBtn.onclick = () => {
  editMode = !editMode;
  toggleEditBtn.textContent = "ç·¨é›†ãƒ¢ãƒ¼ãƒ‰: " + (editMode ? "ON" : "OFF");

  stage.querySelectorAll(".light").forEach(light => {
    if (editMode) {
      makeDraggable(light);
      light.style.borderColor = "#555";
    } else {
      light.onmousedown = null;
      light.style.borderColor = "#aaa";
    }
  });
  
  stage.querySelectorAll(".other").forEach(other => {
    if (editMode) {
      makeDraggable(other);
      other.style.borderColor = "#555";
    } else {
      other.onmousedown = null;
      other.style.borderColor = "#aaa";
    }
  });

  stage.querySelectorAll(".stand").forEach(stand => {
    if (editMode) {
      makeDraggable(stand);
      stand.style.borderColor = "#555";
    } else {
      stand.onmousedown = null;
      stand.style.borderColor = "#aaa";
    }
  });

    stage.querySelectorAll(".controller").forEach(controller => {
      if (editMode) {
        makeDraggable(controller);
        controller.style.borderColor = "#555";
      } else {
        controller.onmousedown = null;
        controller.style.borderColor = "#aaa";
      }
    });

    // âœ… ã‚¯ãƒ©ã‚¹ã§è¦‹ãŸç›®ã‚’åˆ¶å¾¡
    if (editMode) {
      stage.classList.remove("stage-non-edit");
    } else {
      stage.classList.add("stage-non-edit");
    }

  // ä¿¡å·ç·šæ¥ç¶šãƒ¢ãƒ¼ãƒ‰ã‚‚OFFã«ã™ã‚‹
  lineConnectMode = false;
  connectingLights = [];
  connectingControllers = [];
  updateLineConnectModeUI();
};

// polylineï¼ˆä¿¡å·ç·šï¼‰ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã®é–¢æ•°ï¼ˆä¸­é–“ç‚¹ãªã©ã‚’åæ˜ ï¼‰
function updatePolyline(polyline, points) {
  polyline.setAttribute("points", points.map(p => `${p.x},${p.y}`).join(" "));
}



// ç¯ä½“è¿½åŠ 
addLightBtn.onclick = () => {
  lightCount++;

  const selectedType = fixtureSelector.value;

  let classType = "";
  let displayName = "";

  switch (selectedType) {
    case "STINGERâ…¡":
      classType = "stinger";
      displayName = "STINGER2";
      companyName = "ADJ";
      break;
    case "SWEEPER BEAM QUAD LED":
      classType = "sweeper";
      displayName = "sweeper";
      companyName = "ADJ";
      break;
    case "LIGHT BOX":
      classType = "metubusi";
      displayName = "ç›®æ½°ã—";
      companyName = "I don't know";
      break;
    case "Sunray TRI LED":
      classType = "sunray";
      displayName = "ãƒŸãƒ©ãƒœ";
      companyName = "Sunray";
      break;
    case "Tiny LED":
      classType = "tiny";
      displayName = "tiny";
      companyName = "I don't know";
      break;
    case "Inno Spot":
      classType = "inno";
      displayName = "Inno";
      companyName = "ADJ";
      break;
    case "QUADRA Par120 mk-3":
      classType = "mk3";
      displayName = "120";
      companyName = "ADJ";
      break;
    case "Dotz Par":
      classType = "dotz";
      displayName = "LED";
      companyName = "ADJ";
      break;
    case "E-PAR56LED mk2":
      classType = "mk2";
      displayName = "56";
      companyName = "ADJ";
      break;
    case "LED PAR64":
      classType = "ledpar";
      displayName = "LEDPAR";
      companyName = "ADJ";
      break;
    case "CSPOT26":
      classType = "cspot";
      displayName = "CSPOT";
      companyName = "ADJ";
      break;  
    default:
      classType = "";
      displayName = "L";
  }

  const light = document.createElement("div");
  light.className = `light ${classType}`;
  light.textContent = `${displayName}${lightCount}`;
  light.style.left = "100px";
  light.style.top = (100 + lightCount * 40) + "px";

  // åˆ¶å¾¡ãƒœã‚¿ãƒ³ã¯å‰Šé™¤æ©Ÿèƒ½ã ã‘ã«çµã‚‹ï¼ˆä»–ã¯çœç•¥ï¼‰
  // ã“ã“ã¯æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ç°¡ç•¥åŒ–ã—ã¦ã„ã¾ã™
  // ã‚‚ã—å¿…è¦ãªã‚‰è¿½åŠ å¯èƒ½
  // ã“ã“ã§ã¯ä¿¡å·ç·šè¿½åŠ æ©Ÿèƒ½ã‚’å„ªå…ˆ

  stage.appendChild(light);

  // é»’ã„å››è§’ã®ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã‚’ä½œæˆ
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  light.appendChild(resizeHandle);

  let originalAspectRatio = 1;

  // ãƒªã‚µã‚¤ã‚ºæ©Ÿèƒ½ã‚’å®Ÿè£…
  let isResizing = false;

  resizeHandle.addEventListener("mousedown", (e) => {
    e.stopPropagation();
    isResizing = true;

    const rect = light.getBoundingClientRect();
    originalAspectRatio = rect.width / rect.height;
  });
document.addEventListener("mousemove", (e) => {
  if (isResizing) {
    const rect = light.getBoundingClientRect();
    let newWidth = e.clientX - rect.left;
    let newHeight = e.clientY - rect.top;

    // Shiftã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¦ã„ãŸã‚‰ç¸¦æ¨ªæ¯”ã‚’å›ºå®š
    if (e.shiftKey) {
      if (newWidth / newHeight > originalAspectRatio) {
        newWidth = newHeight * originalAspectRatio;
      } else {
        newHeight = newWidth / originalAspectRatio;
      }
    }

    // æœ€å°ã‚µã‚¤ã‚ºã‚’åˆ¶é™ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã ã‘ã©ãŠã™ã™ã‚ï¼‰
    newWidth = Math.max(newWidth, 20);
    newHeight = Math.max(newHeight, 20);

    light.style.width = newWidth + "px";
    light.style.height = newHeight + "px";
  }
});

// ä¿®æ­£: ä¿¡å·ç·šã‚‚è¿½å¾“ã•ã›ã‚‹ã‚ˆã†ã«å¤‰æ›´æ¸ˆã¿
document.addEventListener("mouseup", () => {
  isResizing = false;
});

  

  makeDraggable(light);
  if (editMode) makeDraggable(light);

  // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆè¿½åŠ ï¼ˆé¸æŠ + ä¿¡å·ç·šæ¥ç¶šåˆ¤å®šï¼‰
  light.addEventListener("click", (e) => {
    e.stopPropagation();
    handleLightClick(light, e); // â†æ—¢å­˜ã®é¸æŠå‡¦ç†
    handleControllerClick(light, e); // â†æ–°ã—ãè¿½åŠ 
  });
  

  const rotateHandle = document.createElement("div");
  rotateHandle.className = "rotate-handle";
  light.appendChild(rotateHandle);

let isRotating = false;

rotateHandle.addEventListener("mousedown", (e) => {
  e.stopPropagation();
  isRotating = true;
});

document.addEventListener("mousemove", (e) => {
  if (isRotating) {
    const rect = light.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
    const deg = angle * (180 / Math.PI);

    light.style.transform = `rotate(${deg}deg)`;
    light.dataset.angle = deg; // ä¿å­˜ã—ã¦ãŠãã¨ä¾¿åˆ©
  }
});

// ä¿®æ­£: ä¿¡å·ç·šã‚‚è¿½å¾“ã•ã›ã‚‹ã‚ˆã†ã«å¤‰æ›´æ¸ˆã¿
document.addEventListener("mouseup", () => {
  isRotating = false;
});

// element.addEventListener("click", ...) â† NG
light.addEventListener("click", (e) => {
  e.stopPropagation();
  handleControllerClick(controller, e); // â†æ—¢å­˜ã®é¸æŠå‡¦ç†
  handleControllerClick(controller, e); // â†æ–°ã—ãè¿½åŠ 
});

addToFaderTable(light, classType, `${displayName}${lightCount}`);

//addBentSignalLine(controller, light);// æ›²ãŒã‚Šã®ã‚ã‚‹ä¿¡å·ç·šã‚’è¿½åŠ 
lineExists();

// ãŸã¨ãˆã°ç¯ä½“è¿½åŠ ã®ã¨ã“ã‚ã®æœ«å°¾ã«
updateEquipmentList();
};



addOtherBtn.onclick = () => {
  otherCount++;

  const selectedType = otherSelector.value;
  let classType = "";
  let displayName = "";

  switch (selectedType) {
    case "woodbox":
      classType = "woodbox";
      displayName = "æœ¨ç®±";
      break;
    case "tutu":
      classType = "tutu";
      displayName = "ç­’";
      break;
    default:
      classType = "";
      displayName = "L";
  }

  const other = document.createElement("div");
  other.className = `other ${classType}`;
  other.textContent = `${displayName}${otherCount}`;
  other.style.left = "100px";
  other.style.top = (100 + otherCount * 40) + "px";

  stage.appendChild(other);
  makeDraggable(other);

  // âœ… ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆç™»éŒ²ï¼ˆã“ã“ãŒå¤§äº‹ï¼ï¼‰
  other.addEventListener("click", (e) => {
    e.stopPropagation(); // ã‚¹ãƒ†ãƒ¼ã‚¸å…¨ä½“ã®ã‚¯ãƒªãƒƒã‚¯ã§é¸æŠãŒè§£é™¤ã•ã‚Œãªã„ã‚ˆã†ã«
    handleOtherClick(other, e);
  });

  console.log(`è¿½åŠ ï¼š${displayName}${otherCount}`); // â†ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ–‡å­—åˆ—ã® {} ä¿®æ­£

  updateEquipmentList(); // ã‚³ã‚³å¤§äº‹ï¼
};



    function handleOtherClick(other, e) {
      const multiSelect = e.ctrlKey || e.metaKey;
      const shiftSelect = e.shiftKey;

      const others = Array.from(stage.querySelectorAll(".other"));
      if (shiftSelect && lastSelectedOther && others.includes(lastSelectedOther)) {
        const startIndex = others.indexOf(lastSelectedOther);
        const endIndex = others.indexOf(other);
        const [from, to] = startIndex < endIndex ? [startIndex, endIndex] : [endIndex, startIndex];

        selectedOthers.forEach(l => l.classList.remove("selected"));
        selectedOthers.clear();

        for (let i = from; i <= to; i++) {
          const l = others[i];
          selectedOthers.add(l);
          l.classList.add("selected");
        }
      } else if (multiSelect) {
        if (selectedOthers.has(other)) {
          selectedOthers.delete(other);
          other.classList.remove("selected");
        } else {
          selectedOthers.add(other);
          other.classList.add("selected");
        }
        lastSelectedOther = other;
      } else {
        selectedOthers.forEach(l => l.classList.remove("selected"));
        selectedOthers.clear();
        selectedOthers.add(other);
        other.classList.add("selected");
        lastSelectedOther = other;
      }
      // ãŸã¨ãˆã°ç¯ä½“è¿½åŠ ã®ã¨ã“ã‚ã®æœ«å°¾ã«

    }

    addStandBtn.onclick = () => {
      standCount++;

      const selectedType = standSelector.value;

      let classType = "";
      let displayName = "";

      switch (selectedType) {
        case "blackstand":
          classType = "blackstand";
          displayName = "é»’ã‚¹ã‚¿";
          break;
        case "silverstand":
          classType = "silverstand";
          displayName = "éŠ€ã‚¹ã‚¿";
          break;
        default:
          classType = "";
          displayName = "L";
      }

      const stand = document.createElement("div");
      stand.className = `stand ${classType}`;
      stand.textContent = `${displayName}${standCount}`;
      stand.style.left = "100px";
      stand.style.top = (100 + standCount * 40) + "px";

      stand.addEventListener("click", (e) => {
      e.stopPropagation();
      handleStandClick(stand, e);
    });

    
  // é»’ã„å››è§’ã®ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã‚’ä½œæˆ
const resizeHandle = document.createElement("div");
resizeHandle.className = "resize-handle";
stand.appendChild(resizeHandle);

let originalAspectRatio = 1;

// ãƒªã‚µã‚¤ã‚ºæ©Ÿèƒ½ã‚’å®Ÿè£…
let isResizing = false;

resizeHandle.addEventListener("mousedown", (e) => {
  e.stopPropagation();
  isResizing = true;

  const rect = stand.getBoundingClientRect();
  originalAspectRatio = rect.width / rect.height;
});
document.addEventListener("mousemove", (e) => {
  if (isResizing) {
    const rect = stand.getBoundingClientRect();
    let newWidth = e.clientX - rect.left;
    let newHeight = e.clientY - rect.top;

    // Shiftã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¦ã„ãŸã‚‰ç¸¦æ¨ªæ¯”ã‚’å›ºå®š
    if (e.shiftKey) {
      if (newWidth / newHeight > originalAspectRatio) {
        newWidth = newHeight * originalAspectRatio;
      } else {
        newHeight = newWidth / originalAspectRatio;
      }
    }

    // æœ€å°ã‚µã‚¤ã‚ºã‚’åˆ¶é™ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã ã‘ã©ãŠã™ã™ã‚ï¼‰
    newWidth = Math.max(newWidth, 20);
    newHeight = Math.max(newHeight, 20);

    stand.style.width = newWidth + "px";
    stand.style.height = newHeight + "px";
  }
});

// ä¿®æ­£: ä¿¡å·ç·šã‚‚è¿½å¾“ã•ã›ã‚‹ã‚ˆã†ã«å¤‰æ›´æ¸ˆã¿
document.addEventListener("mouseup", () => {
  isResizing = false;
  isRotating = false;
});

  const rotateHandle = document.createElement("div");
rotateHandle.className = "rotate-handle";
stand.appendChild(rotateHandle);

let isRotating = false;

rotateHandle.addEventListener("mousedown", (e) => {
  e.stopPropagation();
  isRotating = true;
});

document.addEventListener("mousemove", (e) => {
  if (isRotating) {
    const rect = stand.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
    const deg = angle * (180 / Math.PI);

    stand.style.transform = `rotate(${deg}deg)`;
    stand.dataset.angle = deg; // ä¿å­˜ã—ã¦ãŠãã¨ä¾¿åˆ©
  }
});
      stage.appendChild(stand);
      makeDraggable(stand);

      updateEquipmentList();

    };

    function handleStandClick(stand, e) {
      const multiSelect = e.ctrlKey || e.metaKey;
      const shiftSelect = e.shiftKey;

      const stands = Array.from(stage.querySelectorAll(".stand"));
      if (shiftSelect && lastSelectedStand && stands.includes(lastSelectedStand)) {
        const startIndex = stands.indexOf(lastSelectedStand);
        const endIndex = stands.indexOf(stand);
        const [from, to] = startIndex < endIndex ? [startIndex, endIndex] : [endIndex, startIndex];

        selectedStands.forEach(l => l.classList.remove("selected"));
        selectedStands.clear();

        for (let i = from; i <= to; i++) {
          const l = stands[i];
          selectedStands.add(l);
          l.classList.add("selected");
        }
      } else if (multiSelect) {
        if (selectedStands.has(stand)) {
          selectedStands.delete(stand);
          stand.classList.remove("selected");
        } else {
          selectedStands.add(stand);
          stand.classList.add("selected");
        }
        lastSelectedStand = stand;
      } else {
        selectedStands.forEach(l => l.classList.remove("selected"));
        selectedStands.clear();
        selectedStands.add(stand);
        stand.classList.add("selected");
        lastSelectedStand = stand;
      }
    }

addControllerBtn.onclick = () => {
  controllerCount++;

  const selectedType = standController.value;
  let classType = "";
  let displayName = "";

  switch (selectedType) {
    case "phantom2048":
      classType = "phantom2048";
      displayName = "phantom2048";
      break;
    case "SEANESETTER":
      classType = "SEANESETTER";
      displayName = "SEANESETTER";
      break;
    default:
      classType = "";
      displayName = "C";
  }

  const controller = document.createElement("div");
  controller.className = `controller ${classType}`;
  controller.textContent = `${displayName}${controllerCount}`;
  controller.style.left = "100px";
  controller.style.top = (100 + controllerCount * 40) + "px";
  
      const resizeHandle = document.createElement("div");
    resizeHandle.className = "resize-handle";
    controller.appendChild(resizeHandle);

    let originalAspectRatio = 1;

    // ãƒªã‚µã‚¤ã‚ºæ©Ÿèƒ½ã‚’å®Ÿè£…
    let isResizing = false;

    resizeHandle.addEventListener("mousedown", (e) => {
      e.stopPropagation();
      isResizing = true;

      const rect = controller.getBoundingClientRect();
      originalAspectRatio = rect.width / rect.height;
    });
    document.addEventListener("mousemove", (e) => {
    if (isResizing) {
      const rect = controller.getBoundingClientRect();
      let newWidth = e.clientX - rect.left;
      let newHeight = e.clientY - rect.top;

    // Shiftã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¦ã„ãŸã‚‰ç¸¦æ¨ªæ¯”ã‚’å›ºå®š
    if (e.shiftKey) {
      if (newWidth / newHeight > originalAspectRatio) {
        newWidth = newHeight * originalAspectRatio;
      } else {
        newHeight = newWidth / originalAspectRatio;
      }
    }

    // æœ€å°ã‚µã‚¤ã‚ºã‚’åˆ¶é™ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã ã‘ã©ãŠã™ã™ã‚ï¼‰
    newWidth = Math.max(newWidth, 20);
    newHeight = Math.max(newHeight, 20);

    controller.style.width = newWidth + "px";
    controller.style.height = newHeight + "px";
  }
});

// ä¿®æ­£: ä¿¡å·ç·šã‚‚è¿½å¾“ã•ã›ã‚‹ã‚ˆã†ã«å¤‰æ›´æ¸ˆã¿
document.addEventListener("mouseup", () => {
  isResizing = false;
});

  

  makeDraggable(controller);
  if (editMode) makeDraggable(controller);
  // âœ… ã“ã‚Œã ã‘ã§OK
  controller.addEventListener("click", (e) => {
    e.stopPropagation(); // ä»–ã®ã‚¯ãƒªãƒƒã‚¯ã¨å¹²æ¸‰ã—ãªã„ã‚ˆã†ã«
    handleControllerClick(controller, e); // â†æ—¢å­˜ã®é¸æŠå‡¦ç†
    handleConnectableClick(controller, e); // ã“ã‚ŒãŒé¸æŠå‡¦ç†
  });

  stage.appendChild(controller);
  makeDraggable(controller); // â† ã“ã‚Œã¯ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç†

  // element.addEventListener("click", ...) â† NG
controller.addEventListener("click", (e) => {
  e.stopPropagation();
  handleControllerClick(controller, e);
});


  console.log(`è¿½åŠ ï¼š${displayName}${controllerCount}`);
  updateEquipmentList(); // â† ã“ã‚Œã¯è£…å‚™ãƒªã‚¹ãƒˆæ›´æ–°ï¼ˆå•é¡Œãªã—ï¼‰
};


  renderVenueList(); // åˆæœŸåŒ–

function handleControllerClick(controller, e) {
  const multiSelect = e.ctrlKey || e.metaKey;
  const shiftSelect = e.shiftKey;

  if (lineConnectMode) {
    if (!connectingControllers.includes(controller)) {
      connectingControllers.push(controller);
      controller.classList.add("selected");
    }
    if (connectingControllers.length === 2) {
      if (!lineExists(connectingControllers[0], connectingControllers[1])) {
        addBentSignalLine(connectingControllers[0], connectingControllers[1]);
      }
      connectingControllers.forEach(l => l.classList.remove("selected"));
      connectingControllers = [];
    }
    return;
  }

  const controllers = Array.from(stage.querySelectorAll(".controller"));
  if (shiftSelect && lastSelectedController && controllers.includes(lastSelectedController)) {
    const startIndex = controllers.indexOf(lastSelectedController);
    const endIndex = controllers.indexOf(controller);
    const [from, to] = startIndex < endIndex ? [startIndex, endIndex] : [endIndex, startIndex];

    selectedControllers.forEach(l => l.classList.remove("selected"));
    selectedControllers.clear();

    for (let i = from; i <= to; i++) {
      const l = controllers[i];
      selectedControllers.add(l);
      l.classList.add("selected");
    }
  } else if (multiSelect) {
    if (selectedControllers.has(controller)) {
      selectedControllers.delete(controller);
      controller.classList.remove("selected");
    } else {
      selectedControllers.add(controller);
      controller.classList.add("selected");
    }
    lastSelectedController = controller;
  } else {
    selectedControllers.forEach(l => l.classList.remove("selected"));
    selectedControllers.clear();
    selectedControllers.add(controller);
    controller.classList.add("selected");
    lastSelectedController = controller;
  }
}


// æˆ»ã‚‹ãƒœã‚¿ãƒ³
backBtn.onclick = () => {
  stage.style.display = "none";
  venueSelector.style.display = "block";

  // ãƒªã‚»ãƒƒãƒˆ
  selectedLights.clear();
  selectedLines.clear();
  selectedOthers.clear();
  selectedStands.clear();
  lineConnectMode = false;
  connectingLights = [];
  updateLineConnectModeUI();
};

renderVenueList();

let selectedLights = new Set();
let lastSelectedLight = null;

// ä¿¡å·ç·šç®¡ç†ç”¨
let signalLines = [];
const selectedLines = new Set();

// æ¥ç¶šãƒ¢ãƒ¼ãƒ‰
let lineConnectMode = false;
let connectingLights = [];
let connectingController = [];

// ã‚¯ãƒªãƒƒã‚¯æ™‚ã«ç¯ä½“é¸æŠã‚„ç·šæ¥ç¶šã‚’åˆ¤å®š
function handleLightClick(light, e) {
  const multiSelect = e.ctrlKey || e.metaKey;
  const shiftSelect = e.shiftKey;

  if (lineConnectMode) {
    // æ¥ç¶šãƒ¢ãƒ¼ãƒ‰ä¸­ã¯2ã¤ã®ç¯ä½“ã‚’é¸ã¶ã¨ç·šã‚’å¼•ã
    if (!connectingLights.includes(light)) {
      connectingLights.push(light);
      light.classList.add("selected");
    }
    if (connectingLights.length === 2) {
      // æ—¢ã«åŒã˜ç·šãŒã‚ã‚Œã°å¼•ã‹ãªã„
      if (!lineExists(connectingLights[0], connectingLights[1])) {
        addBentSignalLine(connectingLights[0], connectingLights[1]);
      }
      // é¸æŠè§£é™¤ãƒ»ãƒªã‚»ãƒƒãƒˆ
      connectingLights.forEach(l => l.classList.remove("selected"));
      connectingLights = [];
    }
    return;
  }

  // æ™®é€šã®é¸æŠãƒ¢ãƒ¼ãƒ‰
  const lights = Array.from(stage.querySelectorAll(".light"));
  if (shiftSelect && lastSelectedLight && lights.includes(lastSelectedLight)) {
    // ç¯„å›²é¸æŠ
    const startIndex = lights.indexOf(lastSelectedLight);
    const endIndex = lights.indexOf(light);

    const [from, to] = startIndex < endIndex ? [startIndex, endIndex] : [endIndex, startIndex];

    selectedLights.forEach(l => l.classList.remove("selected"));
    selectedLights.clear();

    for (let i = from; i <= to; i++) {
      const l = lights[i];
      selectedLights.add(l);
      l.classList.add("selected");
    }
  } else if (multiSelect) {
    // Ctrl/Cmd è¤‡æ•°é¸æŠãƒˆã‚°ãƒ«
    if (selectedLights.has(light)) {
      selectedLights.delete(light);
      light.classList.remove("selected");
    } else {
      selectedLights.add(light);
      light.classList.add("selected");
    }
    lastSelectedLight = light;
  } else {
    // å˜ä¸€é¸æŠ
    selectedLights.forEach(l => l.classList.remove("selected"));
    selectedLights.clear();
    selectedLights.add(light);
    light.classList.add("selected");
    lastSelectedLight = light;
  }
}


// ã‚¯ãƒªãƒƒã‚¯æ™‚ã«ç¯ä½“é¸æŠã‚„ç·šæ¥ç¶šã‚’åˆ¤å®š
function handleOtherClick(other, e) {
  const multiSelect = e.ctrlKey || e.metaKey;
  const shiftSelect = e.shiftKey;


  // æ™®é€šã®é¸æŠãƒ¢ãƒ¼ãƒ‰
  const others = Array.from(stage.querySelectorAll(".other"));
  if (shiftSelect && lastSelectedOther && others.includes(lastSelectedOther)) {
    // ç¯„å›²é¸æŠ
    const startIndex = others.indexOf(lastSelectedOther);
    const endIndex = others.indexOf(other);

    const [from, to] = startIndex < endIndex ? [startIndex, endIndex] : [endIndex, startIndex];

    selectedOthers.forEach(l => l.classList.remove("selected"));
    selectedOthers.clear();

    for (let i = from; i <= to; i++) {
      const l = others[i];
      selectedOthers.add(l);
      l.classList.add("selected");
    }
  } else if (multiSelect) {
    // Ctrl/Cmd è¤‡æ•°é¸æŠãƒˆã‚°ãƒ«
    if (selectedOthers.has(other)) {
      selectedOthers.delete(other);
      other.classList.remove("selected");
    } else {
      selectedOthers.add(other);
      other.classList.add("selected");
    }
    lastSelectedOther = other;
  } else {
    // å˜ä¸€é¸æŠ
    selectedOthers.forEach(l => l.classList.remove("selected"));
    selectedOthers.clear();
    selectedOthers.add(other);
    other.classList.add("selected");
    lastSelectedOther = other;
  }
}

// ç©ºç™½ã‚¯ãƒªãƒƒã‚¯ã§é¸æŠè§£é™¤
stage.addEventListener("click", () => {
  if (lineConnectMode) return; // æ¥ç¶šãƒ¢ãƒ¼ãƒ‰ã¯è§£é™¤ã•ã›ãªã„
  selectedLights.forEach(l => l.classList.remove("selected"));
  selectedLights.clear();
  selectedOthers.forEach(l => l.classList.remove("selected"));
  selectedOthers.clear();
  selectedStands.forEach(l => l.classList.remove("selected"));
  selectedStands.clear();
  selectedControllers.forEach(l => l.classList.remove("selected"));
  selectedControllers.clear();
  selectedLines.forEach(line => line.classList.remove("selected"));
  selectedLines.clear();
  lastSelectedLight = null;
  lastSelectedController = null;
});

// --- ä¿¡å·ç·šæ©Ÿèƒ½ ---

// ç·šãŒæ—¢ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆç¯ä½“2ã¤ã®çµ„ã¿åˆã‚ã›ï¼‰
// ç·šãŒæ—¢ã«ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
function lineExists(elem1, elem2) {
  return signalLines.some(line =>
    (line.from === elem1 && line.to === elem2) ||
    (line.from === elem2 && line.to === elem1)
  );
}

    function getCenter(el) {
      const rect = el.getBoundingClientRect();
      const stageRect = stage.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2 - stageRect.left,
        y: rect.top + rect.height / 2 - stageRect.top
      };
    }

    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã¨ç¯ä½“ã‚’çµã¶æ›²ã’å¯èƒ½ãªpolylineä¿¡å·ç·šã‚’è¿½åŠ 
    function addBentSignalLine(fromEl, toEl) {
        // ã™ã§ã«åŒã˜ç·šãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      if (signalLines.some(line => 
          (line.from === fromEl && line.to === toEl) || 
          (line.from === toEl && line.to === fromEl))) {
        return; // é‡è¤‡ã‚’é˜²ã
      }
    
      const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
      polyline.setAttribute("stroke", "orange");
      polyline.setAttribute("stroke-width", "3");
      polyline.setAttribute("fill", "none");
      polyline.style.pointerEvents = "visiblePainted"; // ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ã«ã™ã‚‹

      polyline.addEventListener("click", () => {
  showCableLengthSelector(polyline); // â† é¸æŠè‚¢ã‚’å‡ºã—ã¦ dataset.length ã‚’è¨­å®šã™ã‚‹é–¢æ•°
});

      const from = getCenter(fromEl);
      const to = getCenter(toEl);
      const points = [from, to]; // åˆæœŸçŠ¶æ…‹ã§ã¯ç›´ç·š

      polyline.dataset.points = JSON.stringify(points);
      polyline.setAttribute("points", points.map(p => `${p.x},${p.y}`).join(" "));

      signalLinesSVG.appendChild(polyline);

      // ç·šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰ä¸­é–“ã«æ›²ã’ç‚¹ã‚’è¿½åŠ ã—ã¦ãƒãƒ³ãƒ‰ãƒ«ã‚’å‡ºã™
    polyline.addEventListener("click", (e) => {
      e.stopPropagation(); // ä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ­¢ã‚ã‚‹

      // SVGåº§æ¨™ã«å¤‰æ›
      const svgPoint = signalLinesSVG.createSVGPoint();
      svgPoint.x = e.clientX;
      svgPoint.y = e.clientY;
      const pt = svgPoint.matrixTransform(signalLinesSVG.getScreenCTM().inverse());
      
      // 2ç‚¹é–“ã®ä¸­å¤®ã«è¿½åŠ 
      points.splice(1, 0, { x: pt.x, y: pt.y });
      updatePolyline(polyline, points);

      clearBendHandles();// å¤ã„ãƒãƒ³ãƒ‰ãƒ«ã‚’å‰Šé™¤

      // ã™ã¹ã¦ã®æ›²ã’ç‚¹ã«ãƒãƒ³ãƒ‰ãƒ«ã‚’å†ä½œæˆï¼ˆ1ã€œlength-2ã¾ã§ï¼‰
      for (let i = 1; i < points.length - 1; i++) {
        addBendHandle(polyline, points, i);
      }

      polyline.addEventListener("click", (e) => {
  e.stopPropagation(); // ä»–ã®ã‚¯ãƒªãƒƒã‚¯ã¨ãƒãƒƒãƒ†ã‚£ãƒ³ã‚°ã—ãªã„ã‚ˆã†ã«
  // ã™ã§ã«é¸æŠã•ã‚Œã¦ã„ã‚Œã°è§£é™¤ã€ãã‚Œä»¥å¤–ã¯é¸æŠ
  if (selectedLines.has(polyline)) {
    selectedLines.delete(polyline);
    polyline.classList.remove("selected");
  } else {
    selectedLines.add(polyline);
    polyline.classList.add("selected");
  }

  polyline.classList.add("signal-line");

});

  });

  // signalLines ã«ç™»éŒ²ã—ã¦ãŠã
signalLines.push({
  from: fromEl,
  to: toEl,
  polyline: polyline
});
updateEquipmentList();

  }

// pointså±æ€§ã¨ãƒ‡ãƒ¼ã‚¿æ›´æ–°
function updatePolyline(polyline, points) {
  polyline.setAttribute("points", points.map(p => `${p.x},${p.y}`).join(" "));
  polyline.dataset.points = JSON.stringify(points);
}

  // æ—¢å­˜ã®å…¨ã¦ã®æ›²ã’ãƒãƒ³ãƒ‰ãƒ«ã‚’å‰Šé™¤
  function clearBendHandles() {
    const handles = signalLinesSVG.querySelectorAll(".bend-handle");
    handles.forEach(h => h.remove());
  }

// ãƒ™ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’è¡¨ç¤ºãƒ»ãƒ‰ãƒ©ãƒƒã‚°ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
function addBendHandle(polyline, points, index) {
  const pt = points[index];
  const handle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  handle.setAttribute("r", "6");
  handle.setAttribute("fill", "deepskyblue");
  handle.setAttribute("cx", pt.x);
  handle.setAttribute("cy", pt.y);
  handle.style.cursor = "move";

  handle.dataset.index = index;
  handle.classList.add("bend-handle");
  handle.polyline = polyline; // ç´ã¥ã‘å¤§äº‹

  // ğŸ‘‡ ãƒãƒ³ãƒ‰ãƒ«æŠ¼ä¸‹ã§ãƒ‰ãƒ©ãƒƒã‚°çŠ¶æ…‹ã«
  handle.addEventListener("mousedown", (e) => {
    e.stopPropagation(); // ä»–ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã¨å¹²æ¸‰ã—ãªã„ã‚ˆã†ã«

    const onMouseMove = (e) => {
      const stageRect = stage.getBoundingClientRect();
      const x = e.clientX - stageRect.left;
      const y = e.clientY - stageRect.top;

      handle.setAttribute("cx", x);
      handle.setAttribute("cy", y);

      // ä¸­é–“ç‚¹ã®ä½ç½®ã‚’æ›´æ–°
      const points = JSON.parse(polyline.dataset.points);
      points[index] = { x, y };
      polyline.dataset.points = JSON.stringify(points);
      updatePolyline(polyline, points);
    };

    const onMouseUp = () => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    };

    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  signalLinesSVG.appendChild(handle);
}

 // --- ãƒãƒ³ãƒ‰ãƒ«ã®ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç†ï¼ˆãƒã‚¦ã‚¹ã§å‹•ã‹ã›ã‚‹ã‚ˆã†ã«ï¼‰ ---

// ãƒã‚¦ã‚¹æŠ¼ä¸‹æ™‚ã«ãƒ‰ãƒ©ãƒƒã‚°å¯¾è±¡ã‚’ç¢ºèª
signalLinesSVG.addEventListener("mousedown", (e) => {
  if (e.target.classList.contains("bend-handle")) {
    isDragging = true;
    dragHandle = e.target;
  }
});

// ãƒã‚¦ã‚¹ç§»å‹•æ™‚ã«ãƒãƒ³ãƒ‰ãƒ«ã‚’å‹•ã‹ã—ã€ç·šã‚’æ›´æ–°
document.addEventListener("mousemove", (e) => {
  if (!isDragging || !dragHandle) return;

  const svg = signalLinesSVG;
  const pt = svg.createSVGPoint();
  pt.x = e.clientX;
  pt.y = e.clientY;
  const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());

  const index = Number(dragHandle.dataset.index);

  // pointsã¯{x, y}ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…åˆ—ã¨ã—ã¦çµ±ä¸€
  const polyline = dragHandle.polyline; // ç´ã¥ã„ãŸpolylineã‚’å–å¾—// ãƒãƒ³ãƒ‰ãƒ«ã®ç›´å‰ã®polylineã‚’æƒ³å®š
  let points = JSON.parse(polyline.dataset.points);

    // ç§»å‹•ã—ãŸä½ç½®ã‚’åæ˜ 
  points[index] = { x: svgP.x, y: svgP.y };

  // æ›´æ–°
  updatePolyline(polyline, points);
  dragHandle.setAttribute("cx", svgP.x);
  dragHandle.setAttribute("cy", svgP.y);

  polyline.dataset.points = JSON.stringify(points);
});

// ãƒã‚¦ã‚¹ã‚’é›¢ã—ãŸã¨ãã«ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†
// ä¿®æ­£: ä¿¡å·ç·šã‚‚è¿½å¾“ã•ã›ã‚‹ã‚ˆã†ã«å¤‰æ›´æ¸ˆã¿
document.addEventListener("mouseup", () => {
  isDragging = false;
  dragHandle = null;
});

// ç·šã®åº§æ¨™ã‚’æ›´æ–°
function updateSignalLinePosition(signal) {
  const rect1 = signal.from.getBoundingClientRect();
  const rect2 = signal.to.getBoundingClientRect();
  const stageRect = stage.getBoundingClientRect();

  const x1 = rect1.left + rect1.width / 2 - stageRect.left;
  const y1 = rect1.top + rect1.height / 2 - stageRect.top;
  const x2 = rect2.left + rect2.width / 2 - stageRect.left;
  const y2 = rect2.top + rect2.height / 2 - stageRect.top;

  const svgRect = signalLinesSVG.getBoundingClientRect();
  const offsetX = svgRect.left;
  const offsetY = svgRect.top;

  signal.line.setAttribute("x1", x1);
  signal.line.setAttribute("y1", y1);
  signal.line.setAttribute("x2", x2);
  signal.line.setAttribute("y2", y2);

const points = JSON.parse(line.dataset.points);
let sumX = 0, sumY = 0;
points.forEach(p => {
  sumX += p.x;
  sumY += p.y;
});
const centerX = sumX / points.length;
const centerY = sumY / points.length;

label.style.left = `${centerX}px`;
label.style.top = `${centerY - 10}px`; // ã¡ã‚‡ã£ã¨ä¸Šã«ãšã‚‰ã™ã¨è¦‹ã‚„ã™ã„

}

// ç¯ä½“ãŒå‹•ã„ãŸæ™‚ã®ç·šã®æ›´æ–°
function updateLinesForLight(light) {
  signalLines.forEach(signal => {
    if (signal.from === light || signal.to === light) {
      const from = getCenter(signal.from);
      const to = getCenter(signal.to);
      const points = JSON.parse(signal.polyline.dataset.points);

      // ç«¯ç‚¹ã‚’æ›´æ–°ï¼ˆæ›²ã’ç‚¹ã‚’é™¤ã„ã¦å…ˆé ­ãƒ»æœ«å°¾ã ã‘æ›´æ–°ï¼‰
      points[0] = from;
      points[points.length - 1] = to;

      updatePolyline(signal.polyline, points);
    }
  });
}


function updateLinesForController(controller) {
  signalLines.forEach(signal => {
    if (signal.from === controller || signal.to === controller) {
      const from = getCenter(signal.from);
      const to = getCenter(signal.to);
      const points = JSON.parse(signal.polyline.dataset.points);

      points[0] = from;
      points[points.length - 1] = to;

      updatePolyline(signal.polyline, points);
    }
  });
}


// å…¨ã¦ã®ä¿¡å·ç·šã‚’å‰Šé™¤
function clearAllSignalLines() {
  signalLines.forEach(signal => signal.line.remove());
  signalLines = [];
  selectedLines.clear();
}

// ä¿¡å·ç·šãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆUIï¼ˆâ€»ä»Šå›ã¯ä»®ã€å®Ÿè£…ä¾‹ï¼‰
function updateLineConnectModeUI() {
  if (lineConnectMode) {
    toggleEditBtn.style.backgroundColor = "lightyellow";
    toggleEditBtn.textContent = "ç·¨é›†ãƒ¢ãƒ¼ãƒ‰: ONï¼ˆæ¥ç¶šä¸­ï¼‰";
  } else {
    toggleEditBtn.style.backgroundColor = "";
    toggleEditBtn.textContent = "ç·¨é›†ãƒ¢ãƒ¼ãƒ‰: " + (editMode ? "ON" : "OFF");
  }
  connectModeBtn.textContent = "æ¥ç¶šãƒ¢ãƒ¼ãƒ‰: " + (lineConnectMode ? "ON" : "OFF");

}

connectModeBtn.onclick = () => {
  if (!editMode) return; // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã§ãªã‘ã‚Œã°ç„¡åŠ¹
  lineConnectMode = !lineConnectMode;
  connectingLights.forEach(l => l.classList.remove("selected"));
  connectingLights = [];
  connectingControllers.forEach(l => l.classList.remove("selected"));
  connectingControllers = [];
  updateLineConnectModeUI();
};


// æ¥ç¶šãƒ¢ãƒ¼ãƒ‰ã‚’ONã«ã—ãŸã„å ´åˆã¯ã€ãƒœã‚¿ãƒ³è¿½åŠ ã—ã¦ä»¥ä¸‹ã‚’ä½¿ç”¨:
// lineConnectMode = true;
// connectingLights = [];
// updateLineConnectModeUI();



// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
document.addEventListener("keydown", (e) => {
  if (e.key === "Delete" || e.key === "Backspace") {
    // é¸æŠã•ã‚Œã¦ã„ã‚‹ç¯ä½“ã¨ç·šã‚’å‰Šé™¤
    selectedLights.forEach(light => {
      // é–¢é€£ç·šã‚‚å‰Šé™¤
      signalLines = signalLines.filter(lineObj => {
        if (lineObj.light1 === light || lineObj.light2 === light) {
          signalLinesSVG.removeChild(lineObj.line);
          return false;
        }
        return true;
      });

        // ğŸ”» ãƒ•ã‚§ãƒ¼ãƒ€ãƒ¼è¡¨ã®è¡Œã‚‚å‰Šé™¤
  if (light._faderRow) {
    light._faderRow.remove();
  }

      light.remove();
    });
    selectedControllers.forEach(controller => {
      // é–¢é€£ç·šã‚‚å‰Šé™¤
      signalLines = signalLines.filter(lineObj => {
        if (lineObj.controller1 === controller2 || lineObj.controller2 === controller1) {
          signalLinesSVG.removeChild(lineObj.line);
          return false;
        }
        return true;
      });
      controller.remove();
    });
    selectedOthers.forEach(other => {
      other.remove();
    });
    selectedStands.forEach(stand => {
      stand.remove();
    });
    selectedLines.forEach(line => {
  signalLines = signalLines.filter(lineObj => lineObj.polyline !== line);
  line.remove();
});
selectedLines.forEach(line => {
  // é–¢é€£ã™ã‚‹ãƒãƒ³ãƒ‰ãƒ«ã‚‚å‰Šé™¤
  const handles = signalLinesSVG.querySelectorAll(".bend-handle");
  handles.forEach(h => {
    if (h.polyline === line) {
      h.remove();
    }
  });

  // ç™»éŒ²ã•ã‚Œã¦ã‚‹é…åˆ—ã‹ã‚‰é™¤å»
  signalLines = signalLines.filter(lineObj => lineObj.polyline !== line);

  // polylineè‡ªä½“ã‚’å‰Šé™¤
  line.remove();
});


    

    selectedLines.clear();
    selectedLights.clear();
    selectedOthers.clear();
    selectedStands.clear();
    selectedControllers.clear();


    selectedLines.forEach(line => {
      signalLines = signalLines.filter(lineObj => lineObj.line !== line);
      signalLinesSVG.removeChild(line);
    });
    selectedLines.clear();
  }

  // Shift + L ã§ä¿¡å·ç·šæ¥ç¶šãƒ¢ãƒ¼ãƒ‰ON/OFFåˆ‡æ›¿
  if (e.shiftKey && (e.key.toLowerCase() === "l")) {
    lineConnectMode = !lineConnectMode;
    connectingLights.forEach(l => l.classList.remove("selected"));
    connectingLights = [];
    connectingControllers.forEach(l => l.classList.remove("selected"));
    connectingControllers= [];
    updateLineConnectModeUI();
  }
});

// ä¿¡å·ç·šæ¥ç¶šãƒ¢ãƒ¼ãƒ‰ã®UIè¡¨ç¤ºåˆ‡æ›¿
function updateLineConnectModeUI() {
  if (lineConnectMode) {
    toggleEditBtn.textContent = "ä¿¡å·ç·šæ¥ç¶šãƒ¢ãƒ¼ãƒ‰: ON (Shift+Lã§åˆ‡æ›¿)";
    // ç¯ä½“é¸æŠã‚¯ãƒªã‚¢
    selectedLights.forEach(l => l.classList.remove("selected"));
    selectedLights.clear();
    selectedControllers.forEach(l => l.classList.remove("selected"));
    selectedControllers.clear();
  } else {
    toggleEditBtn.textContent = "ç·¨é›†ãƒ¢ãƒ¼ãƒ‰: " + (editMode ? "ON" : "OFF");
  }
  
}

function showCableLengthLabel(line, text) {
  const label = document.createElement("div");
  label.className = "length-label";
  label.textContent = text;

  label.style.position = "absolute";
  label.style.background = "white";
  label.style.border = "1px solid black";
  label.style.padding = "2px 4px";
  label.style.borderRadius = "4px";
  label.style.fontSize = "12px";
  label.style.pointerEvents = "none";
  label.style.transform = "translate(-50%, -50%)";
  label.style.whiteSpace = "nowrap";
  label.style.zIndex = 1000;

  const x1 = parseFloat(line.dataset.x1);
  const y1 = parseFloat(line.dataset.y1);
  const x2 = parseFloat(line.dataset.x2);
  const y2 = parseFloat(line.dataset.y2);

  if ([x1, y1, x2, y2].some(isNaN)) {
    console.warn("ç·šã®åº§æ¨™ãŒä¸æ­£ã§ã™", x1, y1, x2, y2);
    return;
  }

  const centerX = (x1 + x2) / 2;
  const centerY = (y1 + y2) / 2;

  label.style.left = `${centerX}px`;
  label.style.top = `${centerY}px`;

  document.body.appendChild(label);
}


function showCableLengthSelector(line) {
  // ã™ã§ã«ã‚ã‚‹ã‚»ãƒ¬ã‚¯ã‚¿ãŒã‚ã‚Œã°æ¶ˆã™
  const existing = document.getElementById("cableLengthSelector");
  if (existing) {
    existing.remove(); // â† ã“ã‚ŒãŒã€Œæ—¢å­˜ã‚»ãƒ¬ã‚¯ã‚¿ã‚’å‰Šé™¤ã™ã‚‹ã€å‡¦ç†ï¼
  }

  // é¸æŠUIã‚’ä½œæˆ
  const selector = document.createElement("select");
  selector.id = "cableLengthSelector";
  selector.style.position = "absolute";

  // ä¿¡å·ç·šã®ä½ç½®ã‚’å–å¾—ã—ã¦ã‚»ãƒ¬ã‚¯ã‚¿ã‚’ç½®ãä½ç½®ã‚’æ±ºã‚ã‚‹
const bbox = line.getBoundingClientRect();
const centerX = bbox.left + bbox.width / 2 + window.scrollX;
const centerY = bbox.top + bbox.height / 2 + window.scrollY;

selector.style.left = `${centerX}px`;
selector.style.top = `${centerY - 10}px`; // 10px ä¸Šã«ãšã‚‰ã™ï¼ˆå¥½ã¿ã§èª¿æ•´ï¼‰


  // é¸æŠè‚¢è¿½åŠ 
  [1, 3, 5, 10, 15, 20].forEach(len => {
    const option = document.createElement("option");
    option.value = len;
    option.textContent = `${len}m`;
    selector.appendChild(option);
  });

  // å¤‰æ›´æ™‚ã®å‡¦ç†
  selector.addEventListener("change", () => {
  const length = selector.value;
  line.dataset.length = length; // ãƒ‡ãƒ¼ã‚¿å±æ€§ã§ä¿æŒ
  updateEquipmentList();

  // æ—¢ã«é•·ã•ãƒ©ãƒ™ãƒ«ãŒã‚ã‚Œã°æ¶ˆã™
  const existingLabel = line.querySelector(".length-label");
  if (existingLabel) existingLabel.remove();

  // ãƒ©ãƒ™ãƒ«ã‚’ä½œæˆ
  const label = document.createElement("span");
  label.className = "length-label";
  label.textContent = `${length}`;
  label.style.position = "absolute";
  label.style.background = "white";
  label.style.padding = "2px 4px";
  label.style.border = "1px solid black";
  label.style.borderRadius = "4px";
  label.style.fontSize = "12px";
  label.style.pointerEvents = "none";

  // ä¿¡å·ç·šã®ä¸­å¤®ã«é…ç½®
  const x1 = parseInt(line.dataset.x1);
  const y1 = parseInt(line.dataset.y1);
  const x2 = parseInt(line.dataset.x2);
  const y2 = parseInt(line.dataset.y2);
  const centerX = (x1 + x2) / 2;
  const centerY = (y1 + y2) / 2;

  label.style.left = `${centerX}px`;
  label.style.top = `${centerY}px`;

  // stage ä¸Šã«ãƒ©ãƒ™ãƒ«ã‚’è¡¨ç¤º
  stage.appendChild(label);

  // ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚’æ¶ˆã™
  setTimeout(() => selector.remove(), 100);
});

  stage.appendChild(selector); // â† ã‚»ãƒ¬ã‚¯ã‚¿ã‚’èˆå°ã®ä¸Šã«å‡ºã™

}

function setCableLength(line, length) {
  line.dataset.length = length;

  // ãƒ©ãƒ™ãƒ«ã‚‚æ›´æ–°ï¼ˆæ—¢ã«ã‚ã‚‹å ´åˆã¯å‰Šé™¤ï¼‰
  const oldLabel = document.querySelector(`.length-label[data-line-id="${line.dataset.id}"]`);
  if (oldLabel) oldLabel.remove();

  showCableLengthLabel(line, `${length}m`);
  updateEquipmentList();
}



function createLight(x, y) {
  const light = document.createElement('div');
  light.className = `light`;
  //light.textContent = type;
  light.style.left = x + 'px';
  light.style.top = y + 'px';

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚µã‚¤ã‚ºã¨ä½ç½®ï¼ˆå¿…è¦ã«å¿œã˜ã¦èª¿æ•´ï¼‰
  // light.style.left = '100px';
  // light.style.top = '100px';
  // if (!light.style.width) light.style.width = '60px';
  // if (!light.style.height) light.style.height = '30px';

  // ğŸ”§ ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã®è¿½åŠ 
  const handle = document.createElement('div');
  handle.className = 'resize-handle handle-br';
  light.appendChild(handle);

  let isResizing = false;

  handle.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      isResizing = true;
  });

    document.addEventListener('mousemove', (e) => {
      if (isResizing) {
        const rect = light.getBoundingClientRect();
        const stageRect = document.getElementById('stage').getBoundingClientRect();
        const newWidth = e.clientX - rect.left;
        const newHeight = e.clientY - rect.top;
        light.style.width = newWidth + 'px';
        light.style.height = newHeight + 'px';
      }
    });

    document.addEventListener('mouseup', () => {
      isResizing = false;
    });

    document.getElementById('stage').appendChild(controller); // â† controllerã«ä¿®æ­£

    

  return light;
}


function createStand(x, y) {
  const stand = document.createElement('div');
  stand.className = `stand`;
  //light.textContent = type;
  stand.style.left = x + 'px';
  stand.style.top = y + 'px';
const handle = document.createElement('div');
handle.className = 'resize-handle handle-br';
stand.appendChild(handle);

let isResizing = false;

handle.addEventListener('mousedown', (e) => {
  e.stopPropagation();
  isResizing = true;
});

document.addEventListener('mousemove', (e) => {
  if (isResizing) {
    const rect = stand.getBoundingClientRect();
    const stageRect = document.getElementById('stage').getBoundingClientRect();
    const newWidth = e.clientX - rect.left;
    const newHeight = e.clientY - rect.top;
    stand.style.width = newWidth + 'px';
    stand.style.height = newHeight + 'px';
  }
});

document.addEventListener('mouseup', () => {
  isResizing = false;
});

    document.getElementById('stage').appendChild(stand);
    

  return stand;
}

function createController(x, y) {
  const controller = document.createElement('div');
  controller.className = `light`;
  //light.textContent = type;
  controller.style.left = x + 'px';
  controller.style.top = y + 'px';

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚µã‚¤ã‚ºã¨ä½ç½®ï¼ˆå¿…è¦ã«å¿œã˜ã¦èª¿æ•´ï¼‰
  // light.style.left = '100px';
  // light.style.top = '100px';
  // if (!light.style.width) light.style.width = '60px';
  // if (!light.style.height) light.style.height = '30px';

  // ğŸ”§ ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã®è¿½åŠ 
  const handle = document.createElement('div');
  handle.className = 'resize-handle handle-br';
  controller.appendChild(handle);

  let isResizing = false;

  handle.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      isResizing = true;
  });

    document.addEventListener('mousemove', (e) => {
      if (isResizing) {
        const rect = controller.getBoundingClientRect();
        const stageRect = document.getElementById('stage').getBoundingClientRect();
        const newWidth = e.clientX - rect.left;
        const newHeight = e.clientY - rect.top;
        controller.style.width = newWidth + 'px';
        controller.style.height = newHeight + 'px';
      }
    });

    document.addEventListener('mouseup', () => {
      isResizing = false;
    });

    document.getElementById('stage').appendChild(fixture);
    

  return controller;
}




let currentFixtureCounts = {};
let currentCableCount = 0;
let currentOtherCount = {};

function updateEquipmentList() {
  const fixtureCounts = {};
  const fixtures = document.querySelectorAll(".light");

  fixtures.forEach(fixture => {
    const type = fixture.classList[1];
    fixtureCounts[type] = (fixtureCounts[type] || 0) + 1;
  });

  currentFixtureCounts = fixtureCounts;

  const fixtureListEl = document.getElementById("fixtureList");
  fixtureListEl.innerHTML = "";

  for (const type in fixtureCounts) {
    const li = document.createElement("li");
    li.textContent = `${type}ï¼š${fixtureCounts[type]}å°`;
    fixtureListEl.appendChild(li);
  }

  const cables = document.querySelectorAll(".signal-line");
  const cableCountsByLength = {};

  cables.forEach(cable => {
    const len = cable.dataset.length || "æœªè¨­å®š";
    cableCountsByLength[len] = (cableCountsByLength[len] || 0) + 1;
  });

  const cableListEl = document.getElementById("cableList");
  cableListEl.innerHTML = "";
  for (const len in cableCountsByLength) {
    const li = document.createElement("li");
    li.textContent = `ä¿¡å·ç·š ${len}mï¼š${cableCountsByLength[len]}æœ¬`;
    cableListEl.appendChild(li);
  }

  const otherCounts = {};
  const others = document.querySelectorAll(".other");

  others.forEach(other => {
    const type = other.classList[1] || "ãã®ä»–";
    otherCounts[type] = (otherCounts[type] || 0) + 1;
  });

  currentOtherCounts = otherCounts;

  const otherListEl = document.getElementById("otherList");
  if (otherListEl){
  otherListEl.innerHTML = "";

  for (const type in otherCounts) {
    const li = document.createElement("li");
    li.textContent = `${type}ï¼š${otherCounts[type]}å€‹`;
    otherListEl.appendChild(li);
  }
}

const standCounts = {};
const stands = document.querySelectorAll(".stand");

stands.forEach(stand => {
  const type = stand.classList[1] || "ãã®ä»–";
  standCounts[type] = (standCounts[type] || 0) + 1;
});

currentStandCounts = standCounts;

const standListEl = document.getElementById("standList");
if (standListEl) {
  standListEl.innerHTML = "";

  for (const type in standCounts) {
    const li = document.createElement("li");
    li.textContent = `${type}ï¼š${standCounts[type]}å€‹`;
    standListEl.appendChild(li);
  }
}

const ControllerCounts = {};
const controllers = document.querySelectorAll(".controller");

controllers.forEach(controller => {
  const type = controller.classList[1] || "ãã®ä»–";
  ControllerCounts[type] = (ControllerCounts[type] || 0) + 1;
});

currentControllerCounts = ControllerCounts;

const controllerListEl = document.getElementById("controllerList");
if (controllerListEl) {
  controllerListEl.innerHTML = "";

  for (const type in ControllerCounts) {
    const li = document.createElement("li");
    li.textContent = `${type}ï¼š${ControllerCounts[type]}å€‹`;
    controllerListEl.appendChild(li);
  }
}

}

const fixtureCompanyMap = {
  "stinger": "ADJ",
  "sweeper": "ADJ",
  "metubusi": "",
  "sunray": "sunray",
  "tiny": "tiny",
  "inno": "ADJ",
  "mk3": "",
  "dotz": "ADJ", 
  "mk2": "",
  "ledpar": "",
  "cspot": "",
};

document.getElementById("downloadCsvBtn").addEventListener("click", () => {
  const title = "Material List";

  let csv = `${title}\n`
  csv += "title:\n"
  csv += "Chief:\n"
  csv += "ç¨®é¡,ä¼šç¤¾å,æ©Ÿæå,å€‹æ•°,å‰ãƒã‚§,æ¬å…¥,ä¼šå ´,æ¬å‡º,å¾Œãƒã‚§\n";

  csv += `controller`
  for (const [type, count] of Object.entries(currentControllerCounts)) {
    const company = fixtureCompanyMap[type] || "ä¸æ˜";
    csv += ` , ,${type},${count}\n`;
  }
  csv += `ç¯ä½“`
  for (const [type, count] of Object.entries(currentFixtureCounts)) {
    const company = fixtureCompanyMap[type] || "ä¸æ˜";
    csv += ` ,${company},${type},${count}\n`;
  }

  const cableCounts = {};
  const cables = document.querySelectorAll(".signal-line");
  cables.forEach(line => {
    const length = line.dataset.length || "æœªè¨­å®š";
    cableCounts[length] = (cableCounts[length] || 0) + 1;
  });

  csv += `\nã‚¹ã‚¿ãƒ³ãƒ‰`
  for (const [type, count] of Object.entries(currentStandCounts)) {
    const company = fixtureCompanyMap[type] || "ä¸æ˜";
    csv += ` , ,${type},${count}\n`;
  }

  csv += "\nCable";
  for (const [length, count] of Object.entries(cableCounts)) {
    csv += ` ,ãƒã‚¤ã‚±ãƒ«${length}m,${count}\n`;
  }
  
  csv += ` , ,é›»æºã‚¿ãƒƒãƒ—,é©å½“,\n`;
  csv += ` , ,é›»æºã‚±ãƒ¼ãƒ–ãƒ«,é»’ã‚´ãƒ­,\n`;

  csv += `\nother`
    for (const [type, count] of Object.entries(currentOtherCounts)) {
    csv += `, ,${type},${count}\n`;
  }
  csv += `, ,ã‚¬ãƒ ãƒ†ãƒ¼ãƒ—, æ²¢å±±, \n`;
  csv += `, ,é¤Šç”Ÿ, æ²¢å±±, \n`;
  csv += `, ,ç™½ãƒ“ãƒ‹, 3, \n`;
  csv += `, ,å·¥å…·ç®±, 2,\n`;
  csv += `, ,ãƒã‚§ãƒƒã‚«ãƒ¼, 1,\n`;


  // BOMä»˜ãUTF-8ã®Uint8Arrayã‚’ä½œæˆ
  const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
  const csvBuffer = new TextEncoder().encode(csv);
  const blob = new Blob([bom, csvBuffer], { type: "text/csv" });

  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "æ©Ÿæãƒªã‚¹ãƒˆ.csv";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

const fixtureChannelMap = {
  stinger: 15,
  sweeper: 8,
  metubusi: 1,
  sunray: 3,
  tiny: 1,
  inno: 16,
  mk3: 6,
  dotz: 6,
  mk2: 6,
  ledpar: 3,
  cspot: 1
};

function addToFaderTable(light, type, name) {
  const faderListBody = document.querySelector("#faderList tbody");

  const row = document.createElement("tr");

  const nameCell = document.createElement("td");
  nameCell.textContent = name;

  const typeCell = document.createElement("td");
  typeCell.textContent = type;

  const addressCell = document.createElement("td");
  const addressInput = document.createElement("input");
  addressInput.type = "number";
  addressInput.style.width = "60px";

  addressInput.addEventListener("change", () => {
    const baseAddr = parseInt(addressInput.value);
    if (isNaN(baseAddr)) return;

    light.dataset.address = baseAddr;

    let label = light.querySelector(".address-label");
    if (!label) {
      label = document.createElement("div");
      label.className = "address-label";
      light.appendChild(label);
    }
    label.textContent = baseAddr;

    const ch = fixtureChannelMap[type] || 1;
    const nextRow = row.nextElementSibling;
    if (nextRow) {
      const nextInput = nextRow.querySelector("input");
      if (nextInput && !nextInput.value) {
        nextInput.value = baseAddr + ch;
        nextInput.dispatchEvent(new Event("change"));
      }
    }
  });

  addressCell.appendChild(addressInput);
  row.appendChild(nameCell);
  row.appendChild(typeCell);
  row.appendChild(addressCell);
  faderListBody.appendChild(row);

  light._faderRow = row;
}

// ExcelJSã§ãƒ•ã‚§ãƒ¼ãƒ€ãƒ¼è¡¨ã‚’Excelã«å‡ºåŠ›ï¼ˆç½«ç·šä»˜ãï¼‰
document.getElementById("downloadFaderCsvBtn").addEventListener("click", async () => {
  const workbook = new ExcelJS.Workbook();
  const sheet = workbook.addWorksheet("ãƒ•ã‚§ãƒ¼ãƒ€ãƒ¼è¡¨");

  // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ
  const headerRows = [
    ["Feder List"],
    ["title:"],
    ["Chief:"],
    ["åå‰", "ç¨®é¡", "ã‚¢ãƒ‰ãƒ¬ã‚¹"]
  ];
  headerRows.forEach(row => sheet.addRow(row));

  // ãƒ‡ãƒ¼ã‚¿å–å¾—
  const rows = Array.from(document.querySelectorAll("#faderList tbody tr"));
  rows.forEach((row, i) => {
    const name = row.cells[0].textContent.trim();
    const type = row.cells[1].textContent.trim();
    const addr = row.cells[2].querySelector("input").value.trim();
    sheet.addRow([name, type, addr]);
    console.log(`è¡Œ${i + 1}: ${name}, ${type}, ${addr}`);
  });

  // ç½«ç·šã‚¹ã‚¿ã‚¤ãƒ«
  const bottomBorderOnly = {
    bottom: { style: 'thin' }
  };
  const thickBorder = {
    top: { style: 'medium' },
    bottom: { style: 'medium' }, 
    left: { style: 'medium' },
    right: { style: 'medium' }
  };

  const rowCount = sheet.rowCount;
  const tableStartIndex = 4; // 4è¡Œç›®ã‹ã‚‰è¡¨ãƒ‡ãƒ¼ã‚¿é–‹å§‹ï¼ˆ1-originï¼‰

  for (let i = 1; i <= rowCount; i++) {
    const row = sheet.getRow(i);
    row.eachCell((cell, colNumber) => {
      let border;

      if (i <= 3) {
        // æœ€åˆã®3è¡Œã¯ä¸‹ç·šã ã‘
        border = bottomBorderOnly;
      }else if(i <= 4){
        border = thickBorder;
      } else if (i === 4) {
        // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã¯å¤ªç·šã®ä¸Šä¸‹æ 
        border = {
          top: { style: 'medium' },
          bottom: { style: 'thin' },
          left: (colNumber === 1) ? { style: 'medium' } : { style: 'thin' },
          right: (colNumber === row.cellCount) ? { style: 'medium' } : { style: 'thin' }
        };
      } else if (i > tableStartIndex && i < rowCount) {
        // è¡¨ã®ä¸­é–“è¡Œã¯å·¦å³ã‚’å¤ªç·šã«ã€ä¸Šä¸‹ã¯ç´°ç·š
        border = {
          top: { style: 'thin' },
          bottom: { style: 'thin' },
          left: (colNumber === 1) ? { style: 'medium' } : { style: 'thin' },
          right: (colNumber === row.cellCount) ? { style: 'medium' } : { style: 'thin' }
        };
      } else if (i === rowCount) {
        // æœ€çµ‚è¡Œã¯ä¸‹ã¨å·¦å³ã‚’å¤ªç·šã«
        border = {
          top: { style: 'thin' },
          bottom: { style: 'medium' },
          left: (colNumber === 1) ? { style: 'medium' } : { style: 'thin' },
          right: (colNumber === row.cellCount) ? { style: 'medium' } : { style: 'thin' }
        };
      } else {
        // ãã‚Œä»¥å¤–ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ç´°ç·š
        border = {
          top: { style: 'thin' },
          bottom: { style: 'thin' },
          left: { style: 'thin' },
          right: { style: 'thin' }
        };
      }
      cell.border = border;
    });
  }

  // ä¿å­˜å‡¦ç†
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], {
    type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  });
  saveAs(blob, "ãƒ•ã‚§ãƒ¼ãƒ€ãƒ¼è¡¨_ç½«ç·šä»˜ã.xlsx");
});




document.getElementById("downloadPdfBtn").addEventListener("click", () => {
  const originalStage = document.getElementById("stage");

  // ã‚¹ãƒ†ãƒ¼ã‚¸ã®ã‚¯ãƒ­ãƒ¼ãƒ³ã‚’ä½œæˆ
  const clone = originalStage.cloneNode(true);

  // ä¸è¦ãªUIè¦ç´ ã‚’å‰Šé™¤ï¼ˆãƒœã‚¿ãƒ³é¡ãªã©ï¼‰
  clone.querySelectorAll("button, select").forEach(el => el.remove());

  // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä¿æŒã—ã¦ç”»é¢å¤–ã«é…ç½®ï¼ˆè¡¨ç¤ºã•ã‚Œãªã„ãŒæç”»ã¯ã•ã‚Œã‚‹ï¼‰
  clone.style.position = "absolute";
  clone.style.left = "-9999px";
  clone.style.top = "0";
  clone.style.display = "block"; // éè¡¨ç¤ºã ã¨æç”»ã§ããªã„

  document.body.appendChild(clone);

  html2canvas(clone, {
    backgroundColor: null,
    useCORS: true,
    scale: 2
  }).then(canvas => {
    const imgData = canvas.toDataURL("image/png");
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({
      orientation: "landscape",
      unit: "px",
      format: [canvas.width, canvas.height]
    });

    pdf.addImage(imgData, "PNG", 0, 0, canvas.width, canvas.height);
    pdf.save("ç…§æ˜å›³.pdf");

    // ã‚¯ãƒ­ãƒ¼ãƒ³å‰Šé™¤
    document.body.removeChild(clone);
  });
});


// ä¿®æ­£ï¼šç¯ä½“ãƒ»ã‚±ãƒ¼ãƒ–ãƒ«ãƒ»ã‚¹ã‚¿ãƒ³ãƒ‰ãƒ»ãã®ä»–ã‚’Excelå‡ºåŠ›ã§ç½«ç·šä»˜ãã«åæ˜ 

// è©²å½“éƒ¨åˆ†ã ã‘å·®ã—æ›¿ãˆï¼ˆæ—¢å­˜ã® downloadExcel ãƒªã‚¹ãƒŠãƒ¼ã‚’ä¸Šæ›¸ãï¼‰
document.getElementById("downloadExcel").addEventListener("click", async () => {
  const workbook = new ExcelJS.Workbook();
  const sheet = workbook.addWorksheet("æ©Ÿæãƒªã‚¹ãƒˆ");



  const rows = [];
  rows.push(["Material List"]);
  rows.push(["title:"]);
  rows.push(["Chief:"]);
  rows.push(["ç¨®é¡", "ä¼šç¤¾å", "æ©Ÿæå", "å€‹æ•°", "å‰ãƒã‚§", "æ¬å…¥", "ä¼šå ´", "æ¬å‡º", "å¾Œãƒã‚§"]);

  const tableStartIndex = rows.findIndex(row => row[0] === "ç¨®é¡");

  const borderStyle = {
    top: { style: 'thin' },
    bottom: { style: 'thin' },
    left: { style: 'thin' },
    right: { style: 'thin' }
  };


  const bottomBorderOnly = {
    bottom: { style: 'thin' }
  };

  const thick_Bordder = {
    top: { style: 'medium' },
    bottom: { style: 'medium' }, 
    left: { style: 'medium' },
    right: { style: 'medium' }
  }


 

  // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
  rows.push(["controller","","","","","","","",""]);
  for (const [type, count] of Object.entries(currentControllerCounts)) {
    const company = fixtureCompanyMap[type] || "ä¸æ˜";
    rows.push(["", "", type, count,"","","","",""]);
  }

  // ç¯ä½“
  rows.push(["ç¯ä½“","","","","","","","",""]);
  for (const [type, count] of Object.entries(currentFixtureCounts)) {
    const company = fixtureCompanyMap[type] || "ä¸æ˜";
    rows.push(["", company, type, count,"","","","",""]);
  }

  // ã‚¹ã‚¿ãƒ³ãƒ‰
  rows.push(["ã‚¹ã‚¿ãƒ³ãƒ‰","","","","","","","",""]);
  for (const [type, count] of Object.entries(currentStandCounts)) {
    const company = fixtureCompanyMap[type] || "ä¸æ˜";
    rows.push(["", "", type, count,"","","","","",]);
  }

  // ã‚±ãƒ¼ãƒ–ãƒ«
  const cableCounts = {};
  const cables = document.querySelectorAll(".signal-line");
  cables.forEach(line => {
    const length = line.dataset.length || "æœªè¨­å®š";
    cableCounts[length] = (cableCounts[length] || 0) + 1;
  });

  rows.push(["Cable","","","","","","","",""]);
  for (const [length, count] of Object.entries(cableCounts)) {
    rows.push(["", `ãƒã‚¤ã‚±ãƒ«${length}m`, "", count,"","","","",""]);
  }
  rows.push(["", "", "é›»æºã‚¿ãƒƒãƒ—", "é©å½“","","","","",""]);
  rows.push(["", "", "é›»æºã‚±ãƒ¼ãƒ–ãƒ«", "é»’ã‚´ãƒ­","","","","",""]);

  // ãã®ä»–
  rows.push(["other","","","","","","","",""]);
  for (const [type, count] of Object.entries(currentOtherCounts)) {
    rows.push(["", "", type, count,"","","","",""]);
  }
  rows.push(["", "", "ã‚¬ãƒ ãƒ†ãƒ¼ãƒ—", "æ²¢å±±","","","","",""]);
  rows.push(["", "", "é¤Šç”Ÿ", "æ²¢å±±","","","","",""]);
  rows.push(["", "", "ç™½ãƒ“ãƒ‹", 3,"","","","",""]);
  rows.push(["", "", "å·¥å…·ç®±", 2,"","","","",""]);
  rows.push(["", "", "ãƒã‚§ãƒƒã‚«ãƒ¼", 1,"","","","",""]);

  const tableEndIndex = rows.length - 1;

// Excelã«è¡Œè¿½åŠ ï¼‹ç½«ç·šé©ç”¨
rows.forEach((rowData, rowIndex) => {
  const row = sheet.addRow(rowData);

  row.eachCell((cell, colNumber) => {
    let border = {
      top: { style: 'thin' },
      bottom: { style: 'thin' },
      left: { style: 'thin' },
      right: { style: 'medium' }
    };

    // æœ€åˆã®3è¡Œ â†’ ä¸‹ç·šã ã‘
    if (rowIndex <= 2) {
      border = bottomBorderOnly;
    } else if (rowIndex <= 3){
      border = thick_Bordder;
    } else if (rowIndex === tableStartIndex) {
      border = {
        top: { style: 'medium' },
        bottom: { style: 'thin' },
        left: (colNumber === 1) ? { style: 'medium' } : { style: 'thin' },
        right: (colNumber === rowData.length) ? { style: 'medium' } : { style: 'thin' }
      };

    // è¡¨ã®ä¸­é–“è¡Œ â†’ å¤–æ ã ã‘å¤ªç·š
    } else if (rowIndex > tableStartIndex && rowIndex < tableEndIndex) {
      border = {
        top: { style: 'thin' },
        bottom: { style: 'thin' },
        left: (colNumber === 1) ? { style: 'medium' } : { style: 'thin' },
        right: (colNumber === rowData.length) ? { style: 'medium' } : { style: 'thin' }
      };

    // è¡¨ã®æœ€çµ‚è¡Œ â†’ ä¸‹ã¨å·¦å³ã‚’å¤ªç·šã«
    } else if (rowIndex === tableEndIndex) {
      border = {
        top: { style: 'thin' },
        bottom: { style: 'medium' },
        left: (colNumber === 1) ? { style: 'medium' } : { style: 'thin' },
        right: (colNumber === rowData.length) ? { style: 'medium' } : { style: 'thin' }
      };
    }

    cell.border = border;
  });
});

  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], {
    type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  });
  saveAs(blob, "æ©Ÿæãƒªã‚¹ãƒˆ_ç½«ç·šä»˜ã.xlsx");
});





// åˆæœŸåŒ–æ™‚UI
updateLineConnectModeUI();

</script>
</body>
</html>
